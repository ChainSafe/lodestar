/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** The length of a secret key. */
export const SECRET_KEY_LENGTH: number
/** The length of a serialized public key. */
export const PUBLIC_KEY_LENGTH_COMPRESSED: number
export const PUBLIC_KEY_LENGTH_UNCOMPRESSED: number
/** The length of a serialized signature. */
export const SIGNATURE_LENGTH_COMPRESSED: number
export const SIGNATURE_LENGTH_UNCOMPRESSED: number
export interface SignatureSet {
  msg: Uint8Array
  pk: PublicKey
  sig: Signature
}
export interface PkAndSerializedSig {
  pk: PublicKey
  sig: Uint8Array
}
export interface PkAndSig {
  pk: PublicKey
  sig: Signature
}
/**
 * Aggregate multiple public keys into a single public key.
 *
 * If `pks_validate` is `true`, the public keys will be infinity and group checked.
 */
export declare function aggregatePublicKeys(pks: Array<PublicKey>, pksValidate?: boolean | undefined | null): PublicKey
/**
 * Aggregate multiple signatures into a single signature.
 *
 * If `sigs_groupcheck` is `true`, the signatures will be group checked.
 */
export declare function aggregateSignatures(sigs: Array<Signature>, sigsGroupcheck?: boolean | undefined | null): Signature
/**
 * Aggregate multiple serialized public keys into a single public key.
 *
 * If `pks_validate` is `true`, the public keys will be infinity and group checked.
 */
export declare function aggregateSerializedPublicKeys(pks: Array<Uint8Array>, pksValidate?: boolean | undefined | null): PublicKey
/**
 * Aggregate multiple serialized signatures into a single signature.
 *
 * If `sigs_groupcheck` is `true`, the signatures will be group checked.
 */
export declare function aggregateSerializedSignatures(sigs: Array<Uint8Array>, sigsGroupcheck?: boolean | undefined | null): Signature
/**
 * Aggregate multiple public keys and multiple serialized signatures into a single blinded public key and blinded signature.
 *
 * Signatures are deserialized and validated with infinity and group checks before aggregation.
 */
export declare function aggregateWithRandomness(sets: Array<PkAndSerializedSig>): PkAndSig
/**
 * Verify a signature against a message and public key.
 *
 * If `pk_validate` is `true`, the public key will be infinity and group checked.
 *
 * If `sig_groupcheck` is `true`, the signature will be group checked.
 */
export declare function verify(msg: Uint8Array, pk: PublicKey, sig: Signature, pkValidate?: boolean | undefined | null, sigGroupcheck?: boolean | undefined | null): boolean
/**
 * Verify an aggregated signature against multiple messages and multiple public keys.
 *
 * If `pk_validate` is `true`, the public keys will be infinity and group checked.
 *
 * If `sigs_groupcheck` is `true`, the signatures will be group checked.
 */
export declare function aggregateVerify(msgs: Array<Uint8Array>, pks: Array<PublicKey>, sig: Signature, pkValidate?: boolean | undefined | null, sigsGroupcheck?: boolean | undefined | null): boolean
/**
 * Verify an aggregated signature against a single message and multiple public keys.
 *
 * Proof-of-possession is required for public keys.
 *
 * If `sigs_groupcheck` is `true`, the signatures will be group checked.
 */
export declare function fastAggregateVerify(msg: Uint8Array, pks: Array<PublicKey>, sig: Signature, sigsGroupcheck?: boolean | undefined | null): boolean
/**
 * Verify multiple aggregated signatures against multiple messages and multiple public keys.
 *
 * If `pks_validate` is `true`, the public keys will be infinity and group checked.
 *
 * If `sigs_groupcheck` is `true`, the signatures will be group checked.
 *
 * See https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407
 */
export declare function verifyMultipleAggregateSignatures(sets: Array<SignatureSet>, pksValidate?: boolean | undefined | null, sigsGroupcheck?: boolean | undefined | null): boolean
export declare class SecretKey {
  /**
   * Generate a secret key deterministically from a secret byte array `ikm`.
   *
   * `ikm` must be at least 32 bytes long.
   *
   * Optionally pass `key_info` bytes to derive multiple independent keys from the same `ikm`.
   * By default, the `key_info` is empty.
   */
  static fromKeygen(ikm: Uint8Array, keyInfo?: Uint8Array | undefined | null): SecretKey
  /**
   * Generate a master secret key deterministically from a secret byte array `ikm` based on EIP-2333.
   *
   * `ikm` must be at least 32 bytes long.
   *
   * See https://eips.ethereum.org/EIPS/eip-2333
   */
  static deriveMasterEip2333(ikm: Uint8Array): SecretKey
  /**
   * Derive a child secret key from a parent secret key based on EIP-2333.
   *
   * See https://eips.ethereum.org/EIPS/eip-2333
   */
  deriveChildEip2333(index: number): SecretKey
  /** Deserialize a secret key from a byte array. */
  static fromBytes(bytes: Uint8Array): SecretKey
  /** Deserialize a secret key from a hex string. */
  static fromHex(hex: string): SecretKey
  /** Serialize a secret key to a byte array. */
  toBytes(): Uint8Array
  /** Serialize a secret key to a hex string. */
  toHex(): string
  /** Return the corresponding public key */
  toPublicKey(): PublicKey
  sign(msg: Uint8Array): Signature
}
export declare class PublicKey {
  /**
   * Deserialize a public key from a byte array.
   *
   * If `pk_validate` is `true`, the public key will be infinity and group checked.
   */
  static fromBytes(bytes: Uint8Array, pkValidate?: boolean | undefined | null): PublicKey
  /**
   * Deserialize a public key from a hex string.
   *
   * If `pk_validate` is `true`, the public key will be infinity and group checked.
   */
  static fromHex(hex: string, pkValidate?: boolean | undefined | null): PublicKey
  /** Serialize a public key to a byte array. */
  toBytes(compress?: boolean | undefined | null): Uint8Array
  /** Serialize a public key to a hex string. */
  toHex(compress?: boolean | undefined | null): string
  /** Validate a public key with infinity and group check. */
  keyValidate(): void
}
export declare class Signature {
  /**
   * Deserialize a signature from a byte array.
   *
   * If `sig_validate` is `true`, the public key will be infinity and group checked.
   *
   * If `sig_infcheck` is `false`, the infinity check will be skipped.
   */
  static fromBytes(bytes: Uint8Array, sigValidate?: boolean | undefined | null, sigInfcheck?: boolean | undefined | null): Signature
  /**
   * Deserialize a signature from a hex string.
   *
   * If `sig_validate` is `true`, the public key will be infinity and group checked.
   *
   * If `sig_infcheck` is `false`, the infinity check will be skipped.
   */
  static fromHex(hex: string, sigValidate?: boolean | undefined | null, sigInfcheck?: boolean | undefined | null): Signature
  /** Serialize a signature to a byte array. */
  toBytes(compress?: boolean | undefined | null): Uint8Array
  /** Serialize a signature to a hex string. */
  toHex(compress?: boolean | undefined | null): string
  /**
   * Validate a signature with infinity and group check.
   *
   * If `sig_infcheck` is `false`, the infinity check will be skipped.
   */
  sigValidate(sigInfcheck?: boolean | undefined | null): void
}
