"use strict";(self.webpackChunk_lodestar_docs=self.webpackChunk_lodestar_docs||[]).push([[5296],{4147:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var a=t(4848),o=t(8453);const r={},s="Data Retention",i={id:"run/beacon-management/data-retention",title:"Data Retention",description:"There are two components for an ethereum node database, the execution client and the beacon node. Both need to hold data for a full node to work correctly. In particular the execution node holds state such as wallet information and smart contract code. It also holds the execution blocks with the transaction record. The beacon node is responsible for holding beacon node blocks and state. The beacon state is responsible primarily for the validator information.",source:"@site/pages/run/beacon-management/data-retention.md",sourceDirName:"run/beacon-management",slug:"/run/beacon-management/data-retention",permalink:"/lodestar/run/beacon-management/data-retention",draft:!1,unlisted:!1,editUrl:"https://github.com/ChainSafe/lodestar/tree/unstable/docs/pages/run/beacon-management/data-retention.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"CLI Reference",permalink:"/lodestar/run/beacon-management/beacon-cli"},next:{title:"Networking",permalink:"/lodestar/run/beacon-management/networking"}},c={},d=[{value:"Data Management",id:"data-management",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"data-retention",children:"Data Retention"}),"\n",(0,a.jsx)(n.p,{children:"There are two components for an ethereum node database, the execution client and the beacon node. Both need to hold data for a full node to work correctly. In particular the execution node holds state such as wallet information and smart contract code. It also holds the execution blocks with the transaction record. The beacon node is responsible for holding beacon node blocks and state. The beacon state is responsible primarily for the validator information."}),"\n",(0,a.jsx)(n.p,{children:"There are several processes that need to store data for Lodestar. These data sets can grow quite large over time so it is important to understand how to manage them so the host machine can support operations effectively."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"$executionDir # this changes depending on the execution client\n    \u2514\u2500\u2500 execution-db\n\n$dataDir # specified by --dataDir on the beacon command\n\u251c\u2500\u2500 .log_rotate_audit.json\n\u251c\u2500\u2500 beacon.log # there can be many of these\n\u251c\u2500\u2500 enr\n\u251c\u2500\u2500 peer-id.json\n\u251c\u2500\u2500 chain-db # default if --dbDir not specified\n\u2502   \u2514\u2500\u2500 (db files)\n\u2514\u2500\u2500 peerstore # default if --peerStoreDir not specified\n    \u2514\u2500\u2500 (peerstore files)\n\n$dataDir # specified by --dataDir on the validator command\n\u251c\u2500\u2500 .log_rotate_audit.json\n\u251c\u2500\u2500 validator.log # there can be many of these\n\u251c\u2500\u2500 validator-db # default if --validatorsDbDir not specified\n\u2502   \u2514\u2500\u2500 (db files)\n\u251c\u2500\u2500 proposerConfigs # default if --proposerDir not specified\n\u2502   \u2514\u2500\u2500 (config files)\n\u251c\u2500\u2500 cache # default if --cacheDir not specified\n\u2502   \u2514\u2500\u2500 (cache files)\n\u251c\u2500\u2500 secrets # default if --secretsDir not specified\n\u2502   \u251c\u2500\u2500 0x8e41b969493454318c27ec6fac90645769331c07ebc8db5037...\n\u2502   \u2514\u2500\u2500 0xa329f988c16993768299643d918a2694892c012765d896a16f...\n\u251c\u2500\u2500 keystores # default if --keystoresDir not specified\n\u2502   \u251c\u2500\u2500 0x8e41b969493454318c27ec6fac90645769331c07ebc8db5037...\n\u2502   \u2502   \u2514\u2500\u2500 voting-keystore.json\n\u2502   \u2514\u2500\u2500 0xa329f988c16993768299643d918a2694892c012765d896a16f...\n\u2502       \u2514\u2500\u2500 voting-keystore.json\n\u2514\u2500\u2500 remoteKeys # default if --remoteKeysDir not specified\n    \u2514\u2500\u2500 0xa329f988c16993768299643d918a2694892c012765d896a16f.json\n"})}),"\n",(0,a.jsx)(n.h2,{id:"data-management",children:"Data Management"}),"\n",(0,a.jsx)(n.p,{children:"Configuring your node to store and prune data is key to success. On average you can expect for the database to grow by the follow amounts:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"execution-db"})," grows at 2-30GB per week"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"chain-db"})," grows at 1GB per month"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"validator-db"})," grows at less than 2MB per year, per key (2000 keys = 4GB per year)"]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"keystores"}),", ",(0,a.jsx)(n.code,{children:"keystore-cache"})," and ",(0,a.jsx)(n.code,{children:"peerstore"})," are not usually very large and are not expected to grow much during normal operation."]}),"\n",(0,a.jsxs)(n.p,{children:["Logs can also become quite large so please check out the section on ",(0,a.jsx)(n.a,{href:"/lodestar/run/logging-and-metrics/log-management",children:"log management"})," for more information."]}),"\n",(0,a.jsxs)(n.p,{children:["There is really only one flag that is needed to manage the data for Lodestar, ",(0,a.jsx)(n.a,{href:"./beacon-cli#--datadir",children:(0,a.jsx)(n.code,{children:"--dataDir"})}),". Other than that handling log management is really the heart of the data management story. Beacon node data is what it is. Depending on the execution client that is chosen, there may be flags to help with data storage growth but that is outside the scope of this document."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var a=t(6540);const o={},r=a.createContext(o);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);