import {SecretKey} from "@chainsafe/bls";
import {Keystore} from "@chainsafe/bls-keystore";
import {
  Api,
  ImportStatus,
  DeletionStatus,
  KeystoreStr,
  SlashingProtectionData,
} from "@chainsafe/lodestar-api/keymanager";
import {fromHexString} from "@chainsafe/ssz";
import {ISlashingProtection, Interchange} from "../slashingProtection";
import {ValidatorStore} from "../services/validatorStore";
import {PubkeyHex} from "../types";
import {Root} from "@chainsafe/lodestar-types";
import {unlink, writeFile} from "fs/promises";

// TODO [DA] move to a better location
// Improve the modelling of the type to prevent secretKey.secretKey usage
export type SecretKeyInfo = {
  secretKey: SecretKey;
  keystorePath?: string;
  unlockSecretKeys?: () => void;
};

export class KeymanagerApi implements Api {
  constructor(
    private readonly validatorStore: ValidatorStore,
    private readonly slashingProtection: ISlashingProtection,
    private readonly genesisValidatorRoot: Uint8Array | Root,
    private readonly secretKeys: SecretKeyInfo[] = [],
    private readonly importKeystoresPath?: string[]
  ) {}

  /**
   * List all validating pubkeys known to and decrypted by this keymanager binary
   *
   * https://github.com/ethereum/keymanager-APIs/blob/0c975dae2ac6053c8245ebdb6a9f27c2f114f407/keymanager-oapi.yaml
   */
  async listKeys(): Promise<{
    data: {
      validatingPubkey: PubkeyHex;
      /** The derivation path (if present in the imported keystore) */
      derivationPath?: string;
      /** The key associated with this pubkey cannot be deleted from the API */
      readonly?: boolean;
    }[];
  }> {
    const pubkeys = this.validatorStore.votingPubkeys();
    return {
      data: pubkeys.map((pubkey) => ({
        validatingPubkey: pubkey,
        derivationPath: "",
        readonly: false,
      })),
    };
  }

  /**
   * Import keystores generated by the Eth2.0 deposit CLI tooling. `passwords[i]` must unlock `keystores[i]`.
   *
   * Users SHOULD send slashing_protection data associated with the imported pubkeys. MUST follow the format defined in
   * EIP-3076: Slashing Protection Interchange Format.
   *
   * @param keystores JSON-encoded keystore files generated with the Launchpad
   * @param passwords Passwords to unlock imported keystore files. `passwords[i]` must unlock `keystores[i]`
   * @param slashingProtection Slashing protection data for some of the keys of `keystores`
   * @returns Status result of each `request.keystores` with same length and order of `request.keystores`
   *
   * https://github.com/ethereum/keymanager-APIs/blob/0c975dae2ac6053c8245ebdb6a9f27c2f114f407/keymanager-oapi.yaml
   */
  async importKeystores(
    keystoresStr: KeystoreStr[],
    passwords: string[],
    slashingProtectionStr: SlashingProtectionData
  ): Promise<{
    data: {
      status: ImportStatus;
      message?: string;
    }[];
  }> {
    // TODO [DA] look into the deserialization infra and if this can be deserialized right away into Interchange
    const interchange = (slashingProtectionStr as unknown) as Interchange;
    await this.slashingProtection.importInterchange(interchange, this.genesisValidatorRoot);

    const statuses: {status: ImportStatus; message?: string}[] = [];

    for (let i = 0; i < keystoresStr.length; i++) {
      try {
        const keystoreStr = keystoresStr[i];
        const password = passwords[i];
        if (password === undefined) {
          throw Error(`No password for keystores[${i}]`);
        }

        const keystore = Keystore.parse(keystoreStr);

        // Check for duplicates and skip keystore before decrypting
        if (this.validatorStore.hasVotingPubkey(keystore.pubkey)) {
          statuses[i] = {status: ImportStatus.duplicate};
          continue;
        }

        // TODO [DA]
        // const secretKey = SecretKey.fromBytes(await keystore.decrypt(password));

        // Import keys to live signer
        // this.validatorStore.addKey(secretKey);

        // Persist keys for latter restarts
        if (this.importKeystoresPath) {
          // TODO [DA] switch file name to the keystore format
          const fileName = `${this.importKeystoresPath.pop()}/key_${Date.now()}.json`;
          await writeFile(fileName, keystoreStr, {encoding: "utf8"});
        }

        statuses[i] = {status: ImportStatus.imported};
      } catch (e) {
        statuses[i] = {status: ImportStatus.error, message: (e as Error).message};
      }
    }

    return {data: statuses};
  }

  /**
   * DELETE must delete all keys from `request.pubkeys` that are known to the keymanager and exist in its
   * persistent storage. Additionally, DELETE must fetch the slashing protection data for the requested keys from
   * persistent storage, which must be retained (and not deleted) after the response has been sent. Therefore in the
   * case of two identical delete requests being made, both will have access to slashing protection data.
   *
   * In a single atomic sequential operation the keymanager must:
   * 1. Guarantee that key(s) can not produce any more signature; only then
   * 2. Delete key(s) and serialize its associated slashing protection data
   *
   * DELETE should never return a 404 response, even if all pubkeys from request.pubkeys have no extant keystores
   * nor slashing protection data.
   *
   * Slashing protection data must only be returned for keys from `request.pubkeys` for which a
   * `deleted` or `not_active` status is returned.
   *
   * @param pubkeys List of public keys to delete.
   * @returns Deletion status of all keys in `request.pubkeys` in the same order.
   *
   * https://github.com/ethereum/keymanager-APIs/blob/0c975dae2ac6053c8245ebdb6a9f27c2f114f407/keymanager-oapi.yaml
   */
  async deleteKeystores(
    pubkeysHex: string[]
  ): Promise<{
    data: {
      status: DeletionStatus;
      message?: string;
    }[];
    slashingProtection: SlashingProtectionData;
  }> {
    const deletedKey: boolean[] = [];

    for (let i = 0; i < pubkeysHex.length; i++) {
      const pubkeyHex = pubkeysHex[i];

      // Remove key from live signer
      // const deleted = this.validatorStore.removeKey(pubkeyHex);
      //deletedKey[i] = deleted;

      // Remove key from persistent storage
      for (const secretKey of this.secretKeys) {
        if (secretKey.secretKey.toPublicKey().toHex() === pubkeyHex) {
          secretKey?.unlockSecretKeys?.();
          if (secretKey?.keystorePath) {
            try {
              await unlink(secretKey?.keystorePath);
            } catch (e) {
              // TODO [DA] log some info
            }
          }
        }
      }
    }

    const pubkeysBytes = pubkeysHex.map((pubkeyHex) => fromHexString(pubkeyHex));

    const interchangeV5 = await this.slashingProtection.exportInterchange(this.genesisValidatorRoot, pubkeysBytes, {
      version: "5",
    });

    // After exporting slashing protection data in bulk, render the status
    const pubkeysWithSlashingProtectionData = new Set(interchangeV5.data.map((data) => data.pubkey));
    const statuses: {status: DeletionStatus; message?: string}[] = [];
    for (let i = 0; i < pubkeysHex.length; i++) {
      const status = deletedKey[i]
        ? DeletionStatus.deleted
        : pubkeysWithSlashingProtectionData.has(pubkeysHex[i])
        ? DeletionStatus.not_active
        : DeletionStatus.not_found;
      statuses[i] = {status};
    }

    return {
      data: statuses,
      slashingProtection: JSON.stringify(interchangeV5),
    };
  }
}
